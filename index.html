<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fullscreen Image Editor with Resize</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        #canvas {
            width: 100vw;
            height: 100vh;
            cursor: default;
            background-color: #f0f0f0;
            display: block;
        }
        #canvas.resize-nw { cursor: nw-resize; }
        #canvas.resize-ne { cursor: ne-resize; }
        #canvas.resize-sw { cursor: sw-resize; }
        #canvas.resize-se { cursor: se-resize; }
            #canvas.move { cursor: move; }
        #imageUpload {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <input type="file" id="imageUpload" accept="image/*">
    <canvas id="canvas"></canvas>

    <script>
        class ImageEditor {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.image = null;
                this.imageX = 0;
                this.imageY = 0;
                this.imageWidth = 0;
                this.imageHeight = 0;
                this.isDragging = false;
                this.dragHandle = null;
                this.handleSize = 10;

              this.isDraggingImage = false;
        this.dragStartX = 0;
        this.dragStartY = 0;

                this.resizeCanvas();
                window.addEventListener('resize', this.resizeCanvas.bind(this));

               this.isShiftPressed = false;
                this.aspectRatio = 1;

                window.addEventListener('keydown', (e) => {
                    if (e.key === 'Shift') this.isShiftPressed = true;
                });
                window.addEventListener('keyup', (e) => {
                    if (e.key === 'Shift') this.isShiftPressed = false;
                });

                this.canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
                this.canvas.addEventListener('mouseleave', this.onMouseUp.bind(this));
            }

          isPointInImage(x, y) {
        return x >= this.imageX && x <= this.imageX + this.imageWidth &&
               y >= this.imageY && y <= this.imageY + this.imageHeight;
    }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.draw();
            }

            fitImageToCanvas() {
                const canvasRatio = this.canvas.width / this.canvas.height;
                const imageRatio = this.image.width / this.image.height;

                if (imageRatio > canvasRatio) {
                    this.imageWidth = this.canvas.width * 0.8;
                    this.imageHeight = this.imageWidth / imageRatio;
                } else {
                    this.imageHeight = this.canvas.height * 0.8;
                    this.imageWidth = this.imageHeight * imageRatio;
                }

                this.imageX = (this.canvas.width - this.imageWidth) / 2;
                this.imageY = (this.canvas.height - this.imageHeight) / 2;
            }

            draw() {
                this.ctx.fillStyle = '#f0f0f0';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.image) {
                    this.ctx.drawImage(
                        this.image,
                        0, 0, this.image.naturalWidth, this.image.naturalHeight,
                        this.imageX, this.imageY, this.imageWidth, this.imageHeight
                    );
                    this.drawHandles();
                }
            }

            drawHandles() {
                const handles = [
                    { x: this.imageX, y: this.imageY, cursor: 'nw-resize' },
                    { x: this.imageX + this.imageWidth, y: this.imageY, cursor: 'ne-resize' },
                    { x: this.imageX, y: this.imageY + this.imageHeight, cursor: 'sw-resize' },
                    { x: this.imageX + this.imageWidth, y: this.imageY + this.imageHeight, cursor: 'se-resize' }
                ];

                this.ctx.fillStyle = 'blue';
                handles.forEach(handle => {
                    this.ctx.fillRect(handle.x - this.handleSize / 2, handle.y - this.handleSize / 2, this.handleSize, this.handleSize);
                });
            }

            getHandle(x, y) {
                const handles = [
                    { x: this.imageX, y: this.imageY, cursor: 'nw-resize' },
                    { x: this.imageX + this.imageWidth, y: this.imageY, cursor: 'ne-resize' },
                    { x: this.imageX, y: this.imageY + this.imageHeight, cursor: 'sw-resize' },
                    { x: this.imageX + this.imageWidth, y: this.imageY + this.imageHeight, cursor: 'se-resize' }
                ];

                for (let handle of handles) {
                    if (Math.abs(x - handle.x) < this.handleSize / 2 && Math.abs(y - handle.y) < this.handleSize / 2) {
                        return handle.cursor;
                    }
                }
                return null;
            }

          onMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        this.dragHandle = this.getHandle(x, y);
        if (this.dragHandle) {
            this.isDragging = true;
        } else if (this.isPointInImage(x, y)) {
            this.isDraggingImage = true;
            this.dragStartX = x - this.imageX;
            this.dragStartY = y - this.imageY;
        }
    }

    onMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        if (this.isDragging) {
            this.resize(x, y);
        } else if (this.isDraggingImage) {
            this.imageX = x - this.dragStartX;
            this.imageY = y - this.dragStartY;
            this.draw();
        } else {
            const handle = this.getHandle(x, y);
            if (handle) {
                this.canvas.className = `resize-${handle.split('-')[0]}`;
            } else if (this.isPointInImage(x, y)) {
                this.canvas.className = 'move';
            } else {
                this.canvas.className = '';
            }
        }
    }

    onMouseUp() {
        this.isDragging = false;
        this.isDraggingImage = false;
        this.dragHandle = null;
    }

          loadImage(src) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        this.image = img;
                        this.aspectRatio = img.naturalWidth / img.naturalHeight;
                        this.fitImageToCanvas();
                        this.draw();
                        resolve();
                    };
                    img.onerror = reject;
                    img.src = src;
                });
            }

          resize(x, y) {
    let newWidth, newHeight, anchorX, anchorY;
    switch (this.dragHandle) {
        case 'nw-resize':
            newWidth = this.imageWidth + this.imageX - x;
            newHeight = this.imageHeight + this.imageY - y;
            anchorX = this.imageX + this.imageWidth;
            anchorY = this.imageY + this.imageHeight;
            break;
        case 'ne-resize':
            newWidth = x - this.imageX;
            newHeight = this.imageHeight + this.imageY - y;
            anchorX = this.imageX;
            anchorY = this.imageY + this.imageHeight;
            break;
        case 'sw-resize':
            newWidth = this.imageWidth + this.imageX - x;
            newHeight = y - this.imageY;
            anchorX = this.imageX + this.imageWidth;
            anchorY = this.imageY;
            break;
        case 'se-resize':
            newWidth = x - this.imageX;
            newHeight = y - this.imageY;
            anchorX = this.imageX;
            anchorY = this.imageY;
            break;
    }

    if (this.isShiftPressed) {
        const aspectRatio = this.imageWidth / this.imageHeight;
        if (newWidth / newHeight > aspectRatio) {
            newWidth = newHeight * aspectRatio;
        } else {
            newHeight = newWidth / aspectRatio;
        }
    }

    // Ensure minimum size
    newWidth = Math.max(newWidth, 20);
    newHeight = Math.max(newHeight, 20);

    // Update image properties
    switch (this.dragHandle) {
        case 'nw-resize':
            this.imageX = anchorX - newWidth;
            this.imageY = anchorY - newHeight;
            break;
        case 'ne-resize':
            this.imageY = anchorY - newHeight;
            break;
        case 'sw-resize':
            this.imageX = anchorX - newWidth;
            break;
        case 'se-resize':
            // No change to imageX and imageY
            break;
    }

    this.imageWidth = newWidth;
    this.imageHeight = newHeight;
    this.draw();
}

          maintainAspectRatio(width, height, corner) {
                const currentRatio = width / height;
                if (currentRatio > this.aspectRatio) {
                    width = height * this.aspectRatio;
                } else {
                    height = width / this.aspectRatio;
                }
                return [width, height];
            }
        }

        const editor = new ImageEditor('canvas');

        document.getElementById('imageUpload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            const reader = new FileReader();

            reader.onload = async (event) => {
                await editor.loadImage(event.target.result);
            };

            reader.readAsDataURL(file);
        });
    </script>
</body>
</html>
